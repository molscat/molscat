      SUBROUTINE BDCTRL(N, MXLAM, NHAM, PSIMCH, VL, IV,
     2                  EINT, CENT, NODEC, ERED,
     3                  EP2RU, CM2RU, RSCALE, EIGMIN, WAVE,
     4                  IMIN, IPRINT)
C  Copyright (C) 2025 J. M. Hutson & C. R. Le Sueur
C  Distributed under the GNU General Public License, version 3
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
C
C  ---------------------------------------------------------------
C  ROUTINE TO PERFORM A BOUND-STATE PROPAGATION. ON EXIT,
C  EIGMIN CONTAINS THE SMALLEST EIGENVALUE OF THE MATCHING MATRIX.
C  Y1 CONTAINS THE MATCHING MATRIX FOR USE BY EVMTCH
C  ---------------------------------------------------------------
C  THIS VERSION ORIGINALLY BY JM Hutson, 1988.
C  MODIFIED BY AE Thornley JULY 94 TO ALLOW WAVEFUNCTION PROPAGATION
C  FOR LDMD PROPAGATOR (ONLY)
C  EXTENDED BY JM Hutson 2006 TO ALLOW HYBRID LDMD/AIRY (ENERGIES ONLY)
C  MODIFIED SEPT 2012 TO ELIMINATE 3RD PROPAGATION PART AND
C  USE THE NUMBER OF NEGATIVE EIGENVALUES OF THE MATCHING MATRIX
C
C  03-12-15 CR Le Sueur:
C  ALLOW MATCHING POINT TO DIFFER FROM CHANGEOVER POINT BETWEEN
C  PROPAGATORS
C  CODE FOR PROPAGATORS EXTENDED TO CODE LONG AND SHORT RANGE
C  SEPARATELY
C
C  DIMENSION STATEMENTS FOR ARGUMENT LIST
      DIMENSION PSIMCH(N)
      DIMENSION VL(*),IV(*),EINT(N),CENT(N)
      LOGICAL WAVE
      ALLOCATABLE :: SUMPSI(:),RAB(:,:),PSIB(:),PSICPY(:),
     1               U(:),Y1(:),Y2(:)

      INTEGER, PARAMETER :: MAXSEG=3

      DIMENSION KREC(2)
C
      DIMENSION STPSEG(MAXSEG),CAYSEG(MAXSEG),TOLSEG(MAXSEG),
     1          DRSEG(MAXSEG),IPRSEG(MAXSEG),RBSEG(MAXSEG),
     2          RESEG(MAXSEG),NSTEPS(MAXSEG),POWSEG(MAXSEG)
      LOGICAL LFIRST
C
C  COMMON BLOCK FOR CONTROL OF USE OF PROPAGATION SCRATCH FILE
      LOGICAL IREAD,IWRITE,IREADR,IWRITR
      COMMON /PRPSCR/ ESHIFT,ISCRU,ISCRUR,IREAD,IWRITE,IREADR,IWRITR
C
C  COMMON BLOCK FOR CONTROL OF PROPAGATION SEGMENTS
      COMMON /RADIAL/ RMNINT,RMXINT,RMID,RMATCH,DRS,DRL,STEPS,STEPL,
     1                POWRS,POWRL,TOLHIS,TOLHIL,CAYS,CAYL,unset,
     2                IPROPS,IPROPL,NSEG
C
C  COMMON BLOCK FOR INPUT/OUTPUT CHANNEL NUMBERS
      LOGICAL IWAVEF
      COMMON /IOCHAN/ IPSISC,IWAVSC,IWAVE,NWVCOL,IWVSTP,IWAVEF

C  TIMING VARIABLES
      DOUBLE PRECISION TIMEI,TIMEP(MAXSEG)

      CHARACTER(2) NCOL,PLUR(0:2)
      CHARACTER(60) F2000
      DATA PLUR/'S.','.','S.'/
C
      NSQ=N*N

      IF (WAVE) THEN
        CALL WVOPEN(N)
        WRITE(NCOL,'(I2)') MIN(N,NWVCOL)
        NCOL=ADJUSTR(NCOL)
        F2000='(1P,E15.7,1X'//NCOL//'(E15.7E3:,1X),/(16X,'//
     1                        NCOL//'(E15.7E3:,1X)))'

        IF (IPRINT.GE.30) WRITE(6,50)
  50    FORMAT('  WRITING OUT WAVEFUNCTION AT EVERY STEP')
      ENDIF
C
      CALL BDPSET(IPRSEG,RBSEG,RESEG,DRSEG,
     1            STPSEG,TOLSEG,CAYSEG,POWSEG,ICHNGE)

      NODEC=0
      NODES=-1
C
      IF (ISCRU.NE.0) REWIND ISCRU
      IF (ISCRUR.NE.0) REWIND ISCRUR

      IWREC=1
      NTSTPS=0
C
C  NOW LOOP OVER THE SEGMENTS.
C
      ALLOCATE (Y2(N*N))
!  Start of long DO loop #1
      DO ISEG=1,NSEG
        CALL GCLOCK(TIMEI)
        NUSED=0
        IPROP=IPRSEG(ISEG)
        CAY=CAYSEG(ISEG)
        DRT=DRSEG(ISEG)
        STEP=STPSEG(ISEG)
        TOLHIT=TOLSEG(ISEG)
        RSTART=RBSEG(ISEG)
        RSTOP=RESEG(ISEG)
        POW=POWSEG(ISEG)

        IF (IREAD) THEN
          READ(ISCRU) RSTART,RSTOP,EFIRST,ISTART,NSTEP,DR
          ESHIFT=ERED-EFIRST
        ELSE
          ISTART=1
          IF (ISEG.EQ.1 .OR. ISEG.EQ.ICHNGE+1) ISTART=0

          CALL DRSET(RSTART,RSTOP,-10.D0,TOLHIT,0.D0,DRT,NSTEP,DR,
     1               unset,IPROP,POW)
          IF (IWRITE) WRITE(ISCRU) RSTART,RSTOP,ERED,ISTART,NSTEP,DR
        ENDIF
        DRSEG(ISEG)=DR
C
C  INITIALISE Y MATRIX (HERE CALLED Y2)
C
        IF (ISTART.EQ.0)
     1    CALL YINIT(Y2,VL,IV,CENT,EINT,
     2               N,MXLAM,NHAM,
     3               ERED,RSTART,EP2RU,CM2RU,RSCALE,
     4               RSTART.LT.RSTOP,IPRINT)
C
C  SKIP CALL TO PROPAGATION ROUTINE IF SEGMENT HAS EXACTLY ZERO LENGTH
C
        IF (RSTART.EQ.RSTOP) THEN
          NODES=0
          IF (IPRINT.GE.8) WRITE(6,60) ISEG,RSTART
  60      FORMAT('  NO PROPAGATION NEEDED FOR SEGMENT',I2,' BECAUSE',
     1           ' RSTART = RSTOP =',F12.4)
          GOTO 125
        ENDIF

!  Start of long IF block #1
        IF (IPROP.EQ.5) THEN
C  JOHNSON'S LOG-DERIVATIVE PROPAGATOR
          CALL LDPROP(N,MXLAM,NHAM,
     1                Y2,VL,IV,EINT,CENT,
     2                RSTART,RSTOP,NSTEP,DR,NODES,
     3                ERED,EP2RU,CM2RU,RSCALE,IPRINT)
C
        ELSEIF (IPROP.EQ.6) THEN
C  MANOLOPOULOS' DIABATIC LOG-DERIVATIVE PROPAGATOR
          CALL MDPROP(N,MXLAM,NHAM,
     1                Y2,VL,IV,EINT,CENT,
     2                RSTART,RSTOP,NSTEP,DR,NODES,IWREC,WAVE,
     3                ERED,EP2RU,CM2RU,RSCALE,IPRINT)

C
        ELSEIF (IPROP.EQ.7) THEN
C  MANOLOPOULOS' QUASI-ADIABATIC LOG-DERIVATIVE PROPAGATOR
          CALL MAPROP(N,MXLAM,NHAM,
     1                Y2,VL,IV,EINT,CENT,
     2                RSTART,RSTOP,NSTEP,DR,NODES,
     3                ERED,EP2RU,CM2RU,RSCALE,IPRINT)
C
        ELSEIF (IPROP.EQ.8) THEN
C  MANOLOPOULOS+GRAY SYMPLECTIC PROPAGATOR
          CALL MGPROP(N,MXLAM,NHAM,
     1                Y2,VL,IV,EINT,CENT,
     2                RSTART,RSTOP,NSTEP,DR,NODES,
     3                ERED,EP2RU,CM2RU,RSCALE,IPRINT)
C
        ELSEIF (IPROP.EQ.9) THEN
C  AIRY PROPAGATOR (LONG-RANGE ONLY)
          CALL AIPROP(N,MXLAM,NHAM,
     1                Y2,VL,IV,EINT,CENT,
     4                RSTART,RSTOP,NSTEP,DR,POW,TOLHIT,NODES,
     5                ERED,EP2RU,CM2RU,RSCALE,IPRINT,IWREC,WAVE)
C
        ELSE
          WRITE(6,110) IPROP
  110     FORMAT(/'  *** ERROR IN BDCTRL. NO IMPLEMENTATION FOR ',
     1           'PROPAGATOR CODE =',I3)
          STOP
        ENDIF
!  End of long IF block #1
C
C  ---------------------------------------------------------------
C  END OF PROPAGATION
C
        IF (IPRINT.GE.8) THEN
          IF (ISEG.EQ.1) WRITE(6,*)
          WRITE(6,120) RSTART,RSTOP,NSTEP,NODES
          CALL GCLOCK(TIMEP(ISEG))
          TIMEP(ISEG)=TIMEP(ISEG)-TIMEI
          WRITE(6,170) ' TIME TAKEN FOR CURRENT PROPAGATION: ',
     1                 TIMEP(ISEG),' CPU SECS.'
        ENDIF
  120   FORMAT('  LOG-DERIVATIVE MATRIX PROPAGATED FROM ',
     1         F12.4,'  TO ',F12.4,'  IN ',I6,'  STEPS.',
     2         I6,' NODES FOUND.')
  170   FORMAT(1X,A,F11.2,A)
C
  125   CONTINUE
        NODEC=NODEC+NODES
        NSTEPS(ISEG)=NSTEP

        IF (ISEG.EQ.ICHNGE) THEN
C  KREC IS USED TO SAVE THE VALUE OF IWREC FOR BOTH PARTS OF WAVEFUNCTION
C  BACK-SUBSTITUTION.
C  IWREC IS WHERE TO READ RAB MATRIX FROM (SO GOES FROM LARGE NUMBER BACK
C  TOWARDS 1 IN BOTH CALLS TO WVBKSB).
          ALLOCATE (Y1(N*N))
          KREC(1)=IWREC
          DO I=1,NSQ
            Y1(I)=Y2(I) ! Y1 IS NOW THE END OF THE OUTWARDS PROPAGATION
          ENDDO
        ELSEIF (ISEG.EQ.NSEG) THEN
          KREC(2)=IWREC
        ENDIF
      ENDDO
!  End of long DO loop #1
C  END OF LOOP OVER SEGMENTS
C

      IF (IPRINT.GE.15) CALL MATPRN(6,Y2,N,N,N,2,Y2,' LOGD MATRIX',1)
      NTSTPS=NTSTPS+NSTEP
C
      DO I=1,NSQ
        Y2(I)=-Y2(I)+Y1(I) ! MATCHING MATRIX IS DEFINED AS INWARD-OUTWARD
        Y1(I)=Y2(I)        ! EVMTCH NEEDS A COPY OF THE MATCHING MATRIX
      ENDDO
C
      IF (IPRINT.GE.12) CALL MATPRN(6,Y2,N,N,N,2,Y2,
     1                              ' MATCHING MATRIX',1)
C
C  DIAGONALISE THE MATCHING MATRIX AND FIND THE EIGENVECTOR CORRESPONDING
C  TO THE SMALLEST EIGENVALUE.
C
      IFAIL=0
      ALLOCATE (U(N))
      CALL DIAGVC(Y2, N, N, U, Y1)
C
C  COUNT THE NUMBER OF NEGATIVE EIGENVALUES AND IDENTIFY THE INDEX OF
C  THE SMALLEST EIGENVALUE.  COPY THE CORRESPONDING EIGENVECTOR INTO
C  PSIMCH
      NEGCNT=0
      EIGMIN=1.D30
      DO I=1,N
        IF (U(I).LE.0.D0) NEGCNT=NEGCNT+1
        IF (ABS(U(I)).GT.ABS(EIGMIN)) CYCLE
        EIGMIN=U(I)
        IMIN=I
      ENDDO
      PSIMAX=0.D0
      DO I=1,N
        PSIMCH(I)=Y1((IMIN-1)*N+I)
        IF (ABS(PSIMCH(I)).GT.ABS(PSIMAX)) PSIMAX=PSIMCH(I)
      ENDDO
      PSISGN=SIGN(1D0,PSIMAX)
      DO I=1,N
        PSIMCH(I)=PSIMCH(I)*PSISGN
      ENDDO
C  INCLUDE NEGCNT INSTEAD OF DOING 3RD PROPAGATION (SEPT 2012)
      NODEC=NODEC+NEGCNT
      IF (IPRINT.GE.8) WRITE(6,70) NEGCNT,PLUR(MIN(2,NEGCNT))
  70  FORMAT('  COUNT OF NEGATIVE EIGENVALUES OF MATCHING MATRIX',
     1       ' GIVES',I6,' ADDITIONAL NODE',A)
C
      IF (IPRINT.GE.9) WRITE(6,80) (I,U(I),I=1,N)
  80  FORMAT(/'  EIGENVALUES OF MATCHING MATRIX ARE:'/
     1       (2X,5(0P,I4,1P,1X,G15.7)))

C
C  REMAINING CODE IS FOR BACK-SUBSTITUTION OF WAVEFUNCTIONS
C
      DEALLOCATE (U,Y1,Y2)
      IF (.NOT.WAVE) RETURN
C
      IF (IPRINT.GE.6) WRITE(6,90) IWAVE
  90  FORMAT(/'  CALCULATING WAVEFUNCTION FOR OUTPUT ON CHANNEL',I3)

C  NEED TWO COPIES OF PSIMCH
      ALLOCATE (PSICPY(N))
      PSICPY=PSIMCH
C
C  REVERSE PROPAGATION FROM RMATCH TO GET WAVEFUNCTION
      ALLOCATE (SUMPSI(N))
      SUMPSI=0D0
!  Start of long DO loop #2
      DO IBACK=1,2
        PSIMCH=PSICPY
        IWREC=KREC(IBACK)
        IF (IBACK.EQ.2) THEN
          JSEGB=NSEG
          JSEGE=ICHNGE+1
        ELSE
          JSEGB=ICHNGE
          JSEGE=1
        ENDIF
C
C  JPREC IS WHERE TO WRITE PSI TO, SO FOR IBACK=1 GOES FROM LARGE NUMBER
C  BACK TOWARDS 1, AND FOR IBACK=2 GOES FROM LARGE NUMBER FORWARDS TO EVEN
C  BIGGER NUMBER (WHEN IBACK=2 WRITE OUT OF FIRST RECORD IS SKIPPED OVER).
        JPREC=KREC(1)
        DO JSEG=JSEGB,JSEGE,-1
          RSTART=RBSEG(JSEG)
          RSTOP=RESEG(JSEG)
          IPROP=IPRSEG(JSEG)
          IF (RSTART.EQ.RSTOP) THEN
            NSTEPS(JSEG)=0
            CYCLE
          ENDIF
          DR=DRSEG(JSEG)
          LFIRST=IBACK.EQ.1 .AND. JSEG.EQ.JSEGB
          IF (NSTEPS(JSEG).LE.7) THEN
            WRITE(6,*) ' *** WARNING: TOO FEW INTERVALS FOR ACCURATE'//
     1                 ' NORMALISATION OF WAVEFUNCTION IN SEGMENT ',
     2                 JSEG
            WRITE(6,*) '              BETWEEN ',RSTART,' AND ',RSTOP
          ENDIF
          CALL WVBKSB(N,RSTART,RSTOP,NSTEPS(JSEG),DR,
     1                PSIMCH,IWREC,SUMPSI,IPRINT,JPREC,LFIRST,
     2                IPROP.NE.9)
          IF (IPRINT.GE.8) WRITE(6,130) RESEG(JSEG),RBSEG(JSEG),
     1                                  NSTEPS(JSEG)
  130     FORMAT(/'  WAVEFUNCTION OBTAINED BY BACK-SUBSTITUTION FROM ',
     1           F10.4,' TO ',F10.4,' IN ',I6, ' STEPS')
        ENDDO
      ENDDO
!  End of long DO loop #2

C  COLLECT THE CONTRIBUTIONS TO THE NORMALISATION CONSTANT
      IF (IPRINT.GE.6) WRITE(6,140)
 140  FORMAT(/"  NORMALISATION INTEGRAL CALCULATED BY SIMPSON'S ",
     1        "EXTENDED RULE FOR EACH CHANNEL")
      ANORM=0.D0
      DO I=1,N
        ANORM=ANORM+SUMPSI(I)
        IF (IPRINT.GE.8) WRITE(6,150) I,SUMPSI(I)
 150    FORMAT(I4,5X,G25.15)
      ENDDO
      DEALLOCATE (SUMPSI,PSICPY)
      IF (IPRINT.GE.6) WRITE(6,160) ANORM
 160  FORMAT(/'  TOTAL NORMALISATION INTEGRAL',5X,G18.10)
C
C  WRITE OUT WAVEFUNCTION TO IWAVE IN ORDER RMIN TO RMAX
C
      NTSTPS=SUM(NSTEPS(1:NSEG))+1
      IPSBEG=1
      IPSSTR=1
      IF (IWVSTP.GE.1) THEN
        IPSSTR=IWVSTP
        NWRTST=(NTSTPS-1)/IWVSTP+1
      ELSEIF (IWVSTP.EQ.-2) THEN
        IPSBEG=NTSTPS
        NWRTST=1
      ENDIF
      CALL WVGRID(RBSEG,RESEG,DRSEG,IPRSEG,NSEG,NWRTST)
      DO I=IPSBEG,NTSTPS,IPSSTR
        READ(IPSISC,REC=I) R,PSIMCH
        IF (IWAVEF) THEN
          WRITE(IWAVE,FMT=F2000) R,PSIMCH/SQRT(ANORM)
        ELSE
          WRITE(IWAVE) R,PSIMCH/SQRT(ANORM)
        ENDIF
      ENDDO
      CLOSE (IPSISC)
      CLOSE (IWAVSC)
C
      RETURN
      END
