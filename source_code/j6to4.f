      SUBROUTINE J6TO4(NSTATE,EASYM,LJ2IN,IPRINT)
C  Copyright (C) 2025 J. M. Hutson & C. R. Le Sueur
C  Distributed under the GNU General Public License, version 3
      USE sizes, ONLY: MXELVL, MXJLVL
      USE basis_data, ONLY: ELEVEL, EMAX, J2MAX, J2MIN, J2STEP, JLEVEL,
     b                      JMAX, JMIN, NLEVEL, ROTI
      USE pair_state, ONLY: JSTATE
C  CRLS 06-2022: CONVERTED TO USE ALLOCATABLE ARRAYS, INCLUDING THE
C                JSTATE ARRAY WHICH IS NOW IN pair_state MODULE
C  CRLS 08-2022: REWRITTEN SO THAT THIS ROUTINE IS ALWAYS USED TO GENERATE
C                ITYP=4 BASIS FROM ITYP=6 BASIS
C                ASYMMETRIC ROTOR ENERGY LEVELS ARE STORED IN EASYM BUT
C                CAN BE OVERWRITTEN BY VALUES READ IN TO ELEVEL ARRAY IF
C                NLEVEL<0
C
C  THIS SUBROUTINE EXPANDS ITYPE=6 (ATOM-ASYMMETRIC TOP) FORMAT BASIS TO
C  ITYPE=4 (LINEAR ROTOR-ASYMMETRIC TOP) BASIS
C
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
      ALLOCATABLE JLNW(:),JTMP(:),JLEVNW(:),JLVTMP(:),
     1            ELEVNW(:),ELVTMP(:),LISTJ2(:),ELIST(:)
      DOUBLE PRECISION EASYM(*)
      INTEGER, PARAMETER :: MAXJ2=50
      LOGICAL LJ2IN

      ALPHAE=ROTI(4)
      BE=ROTI(2)
      DE=ROTI(6)
C
C  WE MUST BE ABLE TO GET J2 FROM J2MIN,J2MAX,J2STEP
C  AND CALCULATE LINEAR ROTOR ENERGY FROM BE
      IF (.NOT.LJ2IN) THEN
        IF (IPRINT.GE.1) WRITE(6,641) J2MIN,J2MAX,J2STEP
  641   FORMAT(/'  COMBINING ASYMMETRIC ROTOR AND LINEAR ROTOR.'//
     1          '  LINEAR ROTOR QUANTUM NUMBERS FROM J2MIN =',I3,
     2          ', J2MAX =',I3,', J2STEP =',I2)
        J2MIN=MAX(J2MIN,0)
        J2MAX=MAX(J2MAX,J2MIN)
        J2STEP=MAX(J2STEP,1)
      ENDIF
      IF (BE.LE.0.D0) THEN
        IF (J2MAX.EQ.0) THEN
C  SET ARBITRARY BE SINCE ENERGY WILL ALWAYS BE ZERO
          BE=1.D0
        ELSE
          WRITE(6,*) ' *** J6TO4.  CANNOT OBTAIN LINEAR ROTOR',
     1               ' ENERGY FROM BE'
          STOP
        ENDIF
      ENDIF
      IF (IPRINT.GE.1) THEN
        WRITE(6,644) BE
  644   FORMAT(/'  LINEAR ROTOR ENERGY LEVELS OBTAINED FROM B(E) =',
     1         F12.6)
        IF (ALPHAE.NE.0.D0) WRITE(6,645) ALPHAE
  645   FORMAT(28X,'CORRECTED FOR ALPHA(E) = ',F12.8)
        IF (DE.NE.0.D0) WRITE(6,646) DE
  646   FORMAT(28X,'CORRECTED FOR D(E) = ',F12.8)
        IF (EMAX.GT.0.D0) WRITE(6,648) EMAX
  648   FORMAT(/'  ENERGY CAP ON BASIS FUNCTIONS IS EMAX =',F14.4)
      ENDIF
C
C  NLNW COUNTS NEW 'NLEVEL'; NNEW COUNTS NEW 'NSTATE'
      MINA=9999999
      MAXA=0
      NNEW=0
      NLNW=0
      NLVIN=1
      ITOP=0
      NKVAL=0
      ISTA=0
C  LOOP OVER ITYPE=6 FORMAT IN JSTATE(NSTATE,6)
      JMIN=9999999
      JMAX=0
      NJTERM=2
!  Start of long IF block #1
      IF (LJ2IN) THEN
        J2MIN=1
        J2STEP=1
        NJTERM=3
        ALLOCATE (LISTJ2(MAXJ2),ELIST(MAXJ2))
C  CHECK ORDERING OF LEVELS - REARRANGE SO THAT LEVELS WITH SAME VALUES OF
C  J1 AND TAU ARE GROUPED TOGETHER.
        ILEV=1
        DO WHILE (ILEV.LT.ABS(NLEVEL))
          J1=JLEVEL(ILEV*3-2)
          ITAU=JLEVEL(ILEV*3-1)
          NMATCH=1
          DO JLEV=ILEV+1,ABS(NLEVEL)
            J1P=JLEVEL(JLEV*3-2)
            ITAUP=JLEVEL(JLEV*3-1)
            IF (J1P.NE.J1 .OR. ITAUP.NE.ITAU) CYCLE
            J2=JLEVEL(JLEV*3)
            ISWOP=ILEV+NMATCH
            IF (JLEV.EQ.ISWOP) CYCLE
            J1P=JLEVEL(ISWOP*3-2)
            ITAUP=JLEVEL(ISWOP*3-1)
            J2P=JLEVEL(ISWOP*3)
            EP=ELEVEL(ISWOP)
            JLEVEL(ISWOP*3-2)=J1
            JLEVEL(ISWOP*3-1)=ITAU
            JLEVEL(ISWOP*3)=J2
            ELEVEL(ISWOP)=ELEVEL(JLEV)
            JLEVEL(JLEV*3-2)=J1P
            JLEVEL(JLEV*3-1)=ITAUP
            JLEVEL(JLEV*3)=J2P
            ELEVEL(JLEV)=EP
            NMATCH=NMATCH+1
          ENDDO
          ILEV=ILEV+NMATCH
        ENDDO
      ELSE
        ALLOCATE (LISTJ2(1),ELIST(1))
      ENDIF
!  End of long IF block #1
!  Start of long DO loop #1
      DO IOLD=1,NSTATE
        J1  =JSTATE(         IOLD)
        ITAU=JSTATE(  NSTATE+IOLD)
        IPAR=JSTATE(2*NSTATE+IOLD)
        ISTA=JSTATE(3*NSTATE+IOLD)
        NK  =JSTATE(4*NSTATE+IOLD)
        MINA=MIN(MINA,ISTA+1)
        MAXA=MAX(MAXA,ISTA+NK)
        NKVAL=NKVAL+NK
        INDX=JSTATE(5*NSTATE+IOLD)
        IF (INDX.NE.IOLD) WRITE(6,690) INDX,IOLD
  690   FORMAT(' *** J6TO4. PROBABLY ERROR. INDX.NE.I',2I6)
C  EXPAND ON J2
        NEXTRA=0
        NLVEX=0
        IF (LJ2IN) THEN
C  FIND VALUES OF J2 FOR THIS (J1,TAU) SET
          NJ2=0
          DO ILEV=1,NLEVEL
            IF (JLEVEL(3*ILEV-2).EQ.J1 .AND. JLEVEL(3*ILEV-1).EQ.ITAU)
     1      THEN
              NJ2=NJ2+1
              IF (NJ2.GT.MAXJ2) THEN
                WRITE(6,*) ' *** WOW! BIG BASIS.',
     1                     '  INCREASE MAXJ2 IN RASYMU'
                STOP
              ENDIF
              LISTJ2(NJ2)=JLEVEL(3*ILEV)
              ELIST(NJ2)=EASYM(IOLD)
            ENDIF
          ENDDO
          J2MAX=NJ2
        ENDIF
        DO J2PROX=J2MIN,J2MAX,J2STEP
          J2=J2PROX
          IF (LJ2IN) J2=LISTJ2(J2PROX)
          NLVEX=NLVEX+1
          NEXTRA=NEXTRA+2*MIN(J1,J2)+1
        ENDDO
        NNEW8=NNEW*8
C  CRLS 06-2022: EVERY TIME A NEW STATE IS INCLUDED, EXPAND THE SIZES OF
C                JLNW, JLEVNW AND ELEVNW BY COPYING THEM TO TEMPORARY ARRAYS,
C                REALLOCATING THEM AS LARGER ARRAYS AND COPYING THE CONTENTS
C                OF THE TEMPORARY ARRAYS BACK
        IF (NNEW.GT.0) THEN
          ALLOCATE (JTMP(NNEW8),JLVTMP(NLNW*3),ELVTMP(NLNW))
          JTMP=JLNW
          JLVTMP=JLEVNW
          ELVTMP=ELEVNW
          DEALLOCATE (JLNW,JLEVNW,ELEVNW)
        ENDIF
        ALLOCATE (JLNW(NNEW8+NEXTRA*8),JLEVNW((NLNW+NLVEX)*3),
     1            ELEVNW(NLNW+NLVEX))
        IF (NNEW.GT.0) THEN
          JLNW(1:NNEW8)=JTMP
          JLEVNW(1:NLNW*3)=JLVTMP
          ELEVNW(1:NLNW)=ELVTMP
          DEALLOCATE (JTMP,JLVTMP,ELVTMP)
        ENDIF

!  Start of long DO loop #2
        DO J2PROX=J2MIN,J2MAX,J2STEP
          J2=J2PROX
          IF (LJ2IN) J2=LISTJ2(J2PROX)
          FJ=DBLE(J2)
          FJ=FJ*(FJ+1.D0)
          E2=(BE-ALPHAE*0.5D0)*FJ - DE*FJ*FJ
          IF (LJ2IN) THEN
            EN=ELIST(J2PROX) + E2
            IF (ELEVEL(NLVIN).NE.0.D0) EN=ELEVEL(NLVIN)
            NLVIN=NLVIN+1
          ELSE
            EN=EASYM(IOLD)+E2
          ENDIF
          IF (EMAX.GT.0.D0 .AND. EN.GT.EMAX) CYCLE
          NLNW=NLNW+1
          IF (NLNW.GT.MXELVL) THEN
            WRITE(6,*) ' *** J6TO4. NUMBER LEVELS EXCEEDS MXELVL',MXELVL
            STOP
          ENDIF
          ELEVNW(NLNW)=EN
          JLEVNW(3*NLNW-2)=J1
          JLEVNW(3*NLNW-1)=ITAU
          JLEVNW(3*NLNW)=J2
          DO J12=ABS(J1-J2),J1+J2
            ITOP=NNEW*8
            JLNW(ITOP+1)=J12
            JLNW(ITOP+2)=J2
            JLNW(ITOP+3)=J1
            JLNW(ITOP+4)=ITAU
            JLNW(ITOP+5)=IPAR
            JLNW(ITOP+6)=ISTA
            JLNW(ITOP+7)=NK
            JLNW(ITOP+8)=NLNW
            JMIN=MIN(JMIN,J12)
            JMAX=MAX(JMAX,J12)
            NNEW=NNEW+1
          ENDDO
        ENDDO
!  End of long DO loop #2
      ENDDO
!  End of long DO loop #1
      DEALLOCATE(LISTJ2,ELIST)

C
C  COPY JLEVNW,ELEVNW BACK TO JLEVEL,ELEVEL
      DO I=1,NLNW
        ELEVEL(I)=ELEVNW(I)
        JLEVEL(3*I-2)=JLEVNW(3*I-2)
        JLEVEL(3*I-1)=JLEVNW(3*I-1)
        JLEVEL(3*I)=JLEVNW(3*I)
      ENDDO
      DEALLOCATE (JLEVNW,ELEVNW)

C  RESET NSTATE; COPY JLNW TO JSTATE, CORRECTING ORDER
      NSTATE=NNEW
      DEALLOCATE (JSTATE)
      ALLOCATE (JSTATE(NSTATE*8))
      ITOP=0
      DO I=1,NSTATE
        IX=I
        DO II=1,8
          ITOP=ITOP+1
          JSTATE(IX)=JLNW(ITOP)
          IX=IX+NSTATE
        ENDDO
      ENDDO

      RETURN
      END
