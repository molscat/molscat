      SUBROUTINE CPL23(N,MXLAM,LAM,NSTATE,JSTATE,JSINDX,L,MVALUE,IEX,
     1                 VL,IPRINT,LFIRST)
C  Copyright (C) 2025 J. M. Hutson & C. R. Le Sueur
C  Distributed under the GNU General Public License, version 3
C
C  CS COUPLING MATRIX FOR LINEAR ROTOR-LINEAR ROTOR (ITYPE=23)
C  SEE (FOR EXAMPLE) EQN 18 OF HEIL, GREEN AND KOURI JCP (1978) 68 2562
C
C  SAVES M-INDEPENDENT PARTS USING NEW DYNAMIC STORAGE
C              AND IVLFL IN VERSION '12X' OF MOLSCAT.
C  VERSION 5.  LINEAR XCPL NOW STORED BACKWARDS IN HI LOCS OF X().
C  JAN 93      IVLFL CHECKED BEFORE CALL CPL23 AND IV NO LONGER USED
C              M-INDEPENDENT PARTS (9-J) STORED IROW.GE.ICOL.
C              M-DEPENDENT (3J) PARTS STORED IF MEMORY ALLOWS.
C
C  CRLS 10-05-22: SAVES COUPLING COEFFICIENTS USING ALLOCATABLE ARRAYS
C
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
      SAVE NL12,J12MX,NJ12,NXPM,NLM,IHL,IXEX,IXTJ,IXMX,ISTART,
     1     IFIRST,CPL9J,CPL3J
C
      INTEGER IPRINT
      INTEGER LAM(*),JSTATE(NSTATE,3),JSINDX(*),L(*)
      LOGICAL LODD,LFIRST
      DIMENSION VL(*)
      ALLOCATABLE CPL3J(:),CPL9J(:),CPLTMP(:)
C
      PARAMETER (SQRTHF=SQRT(0.5D0), Z0=0.D0, 
     1           PIFCT=(4.D0*ACOS(-1.D0))**(-1.5D0))
C  STATEMENT FUNCTION DEFINITIONS
      Z(I)=DBLE(I+I+1)
      LODD(I)=I-2*(I/2).NE.0
C
C  INITIALIZE IFIRST IF LFIRST IS SET TO TRUE
      IF (LFIRST) THEN
        IFIRST=-2
        LFIRST=.FALSE.
        IF (ALLOCATED(CPL9J)) DEALLOCATE (CPL9J)
        IF (ALLOCATED(CPL3J)) DEALLOCATE (CPL3J)
      ENDIF
      XM=MVALUE
C
      PM=PARSGN(MVALUE)

      IF (IFIRST.GT.-2) GOTO 1000

C  FIRST TIME THROUGH EVALUATE MVALUE-INDEPENDENT PARTS OF VL()
C  SET-UP AND CHECK STORAGE ...
      NL12=NSTATE*(NSTATE+1)/2
      IXMX=NL12*MXLAM
      IXEX=IXMX
      IF (IEX.GT.0) IXMX=2*IXMX
      ALLOCATE (CPL9J(IXMX))
C
C  SET-UP THE NINEJ PARTS IN CPL9J().
      DO LL=1,MXLAM
        LM1=LAM(3*LL-2)
        LM2=LAM(3*LL-1)
        LM=LAM(3*LL)
        IL12=0
      DO I1=1,NSTATE
        J1 =JSTATE(I1,1)
        J2 =JSTATE(I1,2)
        J12=JSTATE(I1,3)
      DO I2=1,I1
        IL12=IL12+1
        J1P =JSTATE(I2,1)
        J2P =JSTATE(I2,2)
        J12P=JSTATE(I2,3)
        FACTOR=PIFCT*Z(LM)*SQRT(Z(J12)*Z(J12P)*Z(J1)*Z(J1P)*Z(J2)*Z(J2P)
     1                         *Z(LM1)*Z(LM2))*PARSGN(J1+J2+J12)
        IX=(LL-1)*NL12+IL12
        CPL9J(IX)=FACTOR*THREEJ(J1,LM1,J1P)*THREEJ(J2,LM2,J2P)*
     1                      XNINEJ(J12P,J2P,J1P,J12,J2,J1,LM,LM2,LM1)
        IF (IEX.EQ.0) CYCLE
        IF (J1.EQ.J2) THEN
          CPL9J(IXEX+IX)=CPL9J(IX)
        ELSE
          CPL9J(IXEX+IX)=THREEJ(J2,LM1,J1P)*THREEJ(J1,LM2,J2P)*
     1                 XNINEJ(J12P,J2P,J1P,J12,J1,J2,LM,LM2,LM1)*FACTOR
        ENDIF
      ENDDO
      ENDDO
      ENDDO

C  RESET IFIRST TO INDICATE THAT NINE-J PARTS ARE STORED
      IFIRST=-1
C  NOW CALCULATE PARMS NEEDED TO STORE M-DEPENDENT (THRJ) PARTS.
      J12MX=0
      DO I=1,NSTATE
        J12MX=MAX(J12MX,JSTATE(I,3))
      ENDDO
      NJ12=(J12MX+1)*(J12MX+2)/2
      LMAX=0
      IHL=2
      DO I=1,MXLAM
        IF (LODD(LAM(3*I))) IHL=1
        LMAX=MAX(LMAX,LAM(3*I))
      ENDDO
      NLM=LMAX/IHL+1
      NXPM=NJ12*NLM
C
C  SEE IF REQUIRED M-DEPENDENT VALUES (THRJ) ARE STORED.
C  IF NOT, TRY TO STORE THEM IN CPL3J
 1000 MVABS=ABS(MVALUE)
      IF (.NOT.ALLOCATED(CPL3J)) ALLOCATE(CPL3J(NXPM*(MVABS+1)))
      IF (MVABS.LE.IFIRST) GOTO 2000

      NCPL=SIZE(CPL3J)
      IF (NCPL/NXPM.LE.MVABS) THEN
        ALLOCATE (CPLTMP(NCPL))
        CPLTMP=CPL3J
        DEALLOCATE (CPL3J)
        ALLOCATE (CPL3J(NXPM*(MVABS+1)))
        CPL3J(1:NCPL)=CPLTMP
        DEALLOCATE (CPLTMP)
      ENDIF

      DO MV=IFIRST+1,MVABS

C  UPDATE MEMORY POINTERS AND STORE 3-J VALUES FOR THIS MVAL
        XMV=MV
        LL=0
        DO IL=1,NLM
          XLM=LL
          IXJ12=0
          DO J12=0,J12MX
            XJ12=J12
          DO J12P=0,J12
            XJ12P=J12P
            IXJ12=IXJ12+1
            IX=MV*NXPM+(IL-1)*NJ12+IXJ12
            CPL3J(IX)=THRJ(XJ12,XLM,XJ12P,XMV,Z0,-XMV)
          ENDDO
          ENDDO
          LL=LL+IHL
        ENDDO
      ENDDO
C  RESET IFIRST TO REFLECT HIGHEST M-VALUE STORED.
      IFIRST=MVABS
C
C  FILL VL() FROM XCPL
 2000 NZERO=0
!  Start of long DO loop #1
      DO LL=1,MXLAM
        NNZ=0
        I=LL
        LM=LAM(3*LL)
        XLM=LM
        IL=LM/IHL+1
!  Start of long DO loop #2
        DO ICOL=1,N
          I1=JSINDX(ICOL)
          J1 =JSTATE(I1,1)
          J2 =JSTATE(I1,2)
          J12=JSTATE(I1,3)
          XJ12=J12
!  Start of long DO loop #3
        DO IROW=1,ICOL
          I2=JSINDX(IROW)
          J1P =JSTATE(I2,1)
          J2P =JSTATE(I2,2)
          J12P=JSTATE(I2,3)
          XJ12P=J12P
C  FIRST GET THRJ(J12,LM,J12P,M,0,-M) -- EITHER CALC OR FROM STORAG
C         IF (NOMEM) THEN
C           TJM=THRJ(XJ12,XLM,XJ12P,XM,Z0,-XM)*PM
C         ELSE
C  NB WE HAVE STORED ON J.GE.J'; (J,L,J'/M,0,-M)=(J',L,J/M,0,-M)
C  ALSO, (J,L,J'/-M,0,M)=PARSGN(J+L+J')*(J,L,J'/M,0,-M)
            IF (J12.GE.J12P) THEN
              IXJ12=J12*(J12+1)/2+J12P+1
            ELSE
              IXJ12=J12P*(J12P+1)/2+J12+1
            ENDIF
            IXM=MVABS*NXPM+(IL-1)*NJ12+IXJ12
            TJM=CPL3J(IXM)*PM
            IF (MVALUE.LT.0 .AND. LODD(J12+J12P+LM)) TJM=-TJM
C         ENDIF
C  THEN GET NINEJ() PARTS
          IF (I1.GE.I2) THEN
            IL12=I1*(I1-1)/2+I2
          ELSE
            IL12=I2*(I2-1)/2+I1
          ENDIF
          IX=(LL-1)*NL12+IL12
          VL(I)=CPL9J(IX)*TJM
C *** CODE BELOW ASSUMES THAT SYMMETRICALLY RELATED TERMS ARE BOTH
C *** PRESENT IN POTENTIAL.
          IF (IEX.NE.0) THEN
            IF (J1.EQ.J2) THEN
              T=VL(I)
            ELSE
              T=CPL9J(IXEX+IX)*TJM
            ENDIF
            VL(I)=VL(I)+PARSGN(IEX+J1+J2-J12+L(ICOL))*T
            IF (J1 .EQ.J2)  VL(I)=VL(I)*SQRTHF
            IF (J1P.EQ.J2P) VL(I)=VL(I)*SQRTHF
          ENDIF
          IF (VL(I).NE.0.D0) NNZ=NNZ+1
          I=I+MXLAM
        ENDDO
!  End of long DO loop #3
        ENDDO
!  End of long DO loop #2
        IF (NNZ.LE.0) THEN
          NZERO=NZERO+1
          IF (IPRINT.GE.14) WRITE(6,612) MVALUE,LL
        ENDIF
  612   FORMAT('  * * * NOTE.  FOR MVALUE =',I4,',  ALL COUPLING '
     1         'COEFFICIENTS ARE 0.0 FOR EXPANSION TERM',I4)
      ENDDO
!  End of long DO loop #1

      IF (NZERO.GT.0 .AND. IPRINT.GE.10 .AND. IPRINT.LT.14)
     1  WRITE(6,620) MVALUE,NZERO
  620 FORMAT('  * * * NOTE.  FOR MVALUE =',I4,',  ALL COUPLING ',
     1       'COEFFICIENTS ARE 0.0 FOR',I5,' POTENTIAL EXPANSION TERMS')

      RETURN
C
      END
